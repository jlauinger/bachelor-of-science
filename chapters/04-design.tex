%% -----------------------------------------------------------------------------

\chapter{Design and Implementation}\label{ch:design}
\glsresetall % Resets all acronyms to not used

This chapter proposes a means of detecting MAC addresses through sample correlation. The algorithm is implemented in Matlab as a proof-of-concept.


%% -----------------------------------------------------------------------------

\section{High-Level Detector Design}

The high-level design of a senders detector based on MAC addresses is illustrated in figure \ref{fig:blockdesign}. From the beginning of my work until the final version, multiple design choices have changed. These and their reasons are depicted in detail in Chapter 5. The overall concept has however remained unmodified.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{gfx/images/detector-block-design}
	\caption[High-Level Detector Design Schema]{High-Level Detector Design Schema}
	\label{fig:blockdesign}
\end{figure}

First of all, it is important to decide which MAC addresses should be tried when processing a recevied collision. Since MAC addresses are 6 byte values, there are $2^{48} \approx 3 \cdot 10^{14}$ possible instances. Although some MAC addresses are invalid, since the first three bytes denote the network interface vendor, and not all values have been issued \cite{ieeeoui}, there are still by far too many to try out all of them for every collision.

Instead, I make use of the operating system's ARP stack. During normal network operation, the kernel already keeps a cache of MAC addresses that are reachable. This list is perfectly suited for detecting senders, since it is quite likely that a collision occurs between senders that are already in the network for some time.\\

Next, I modulate IEEE 802.11 data frames for every cached MAC address. These are used as reference signals for correlation with incoming collisions. Only a small part of the reference frames contains the MAC address bits and is important for sender detection. I describe this region in detail in section \ref{sec:mac-periods}.

As mentioned in section \ref{sec:mac-and-phy}, there are different possibilities for frame modulation, namely the \gls{MCS}, the scrambler initialization, and the error-correcting convolutional encoding. Since the encoder uses a 7 bit state, only the MAC header field directly preceeding the sender MAC address is relevant here. That field is the destination MAC address. In theory, all possible combinations could be modulated for the refernce signals cache, however this would mean a total amount of  more than 130 thousand candidates for every MAC address in the ARP pool. In chapter \ref{ch:evaluation} I evaluate which fields matter to which extent.

$$ N_{MCS} \cdot N_{Scrambler} \cdot N_{Dest} = 8 \cdot 127 \cdot 128 = 130 048 $$\vspace{0cm}

The modulation process comprises the following steps:

\begin{enumerate}
	\item Generate a MAC header with appropriate sender and destination MAC addresses
	\item Apply the scrambler with specific initialization value
	\item Run the convolutional encoder, which is deterministic
	\item Group bits and interleave symbols
	\item For a time-domain signal, apply inverse fourier transform and add a cyclic prefix
\end{enumerate}

For correlation in the frequency-domain, I omit step 5. The received collision signal has to be applied to the fourier transform in this case. I have done experiments with frequency-domain detection and show the results of these in section \ref{sec:freqd-correlation}.\\

When the receiver senses a transmission, I determine whether it is a collision using the IEEE 802.11 Long Training Field. Section \ref{sec:preamble-corr} gives details about this process. This also measures a possible delay between the two frames.

Upon noticing a collision, all reference samples are correlated with the signal under test. The correlations are then sorted descending by correlation magnitude. The highest correlations make up for the best guess which senders are subject to the collision.\\

It is worth noting that the output of this algorithm is always a probabilistic result. The technique will never detect senders with full confidence, but rather return a distribution of likelihood over the cache of reasonable MAC addresses.


%% -----------------------------------------------------------------------------

\section{Detecting Frames and Collisions}\label{sec:preamble-corr}

A receiver antenna captures a continuous stream of samples. It is necessary to employ some mechanism to detect the start of a transmission. IEEE 802.11 receivers in regular operation use the known preamble for this by correlating the Long Training Field to the incoming data in a sliding window approach \cite{NEEDED}.

This can be extended to recognizing collisions. Since the Long Training Field is designed in such a way that it hardly correlates with itself \cite{NEEDED}, there will be twice as many correlation peaks in a collision of two frames. The distance between the two LTF pattern can even be used to calculate a possible delay between the two transmissions. An example of such correlation peaks in the case of a collision is shown in figure \ref{fig:preamble-corr}. Each frame causes two large spikes, and 1 spike with smaller magnitude. This is caused by the composition of the LTF with two repetitions of a symbol, and a cyclic prefix of half the symbol size.\\

Knowing when the frames start is important for sender detection. Since the MAC address is represented by only a small number of time-domain samples (see section \ref{sec:mac-periods}), it is vital to correlate the correct region of the signal.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{gfx/images/preamble-correlation}
	\caption{Cross Correlation of Collision Samples with Long Training Field}
	\label{fig:preamble-corr}
\end{figure}

Figure \ref{fig:preamble-corr} offers additional markers for the different signal fields as described in section \ref{sec:mac-and-phy}. Here, the symbols containing the MAC address of the first frame begin after 1120 samples. The second MAC address follows with an offset of about 40 samples.

When trying to decode these MAC addresses, the correlations with the reference pool signals obviously have to be applied to the combined region of the first and second MAC addresses. In this examples, that would be all of the colored samples.


%% -----------------------------------------------------------------------------

\section{Periods containing MAC Addresses}\label{sec:mac-periods}

Depending on the \gls{MCS}, the samples affected by different MAC addresses start at different positions. While the byte offset within the MAC layer header remains the same, the amount of OFDM symbols that need to be skipped before the beginning, and the symbol count that has to be included to cover everything change depending on the bit density.

Table \ref{tbl:sample-offsets} provides a summary of the various samples offsets for different \glspl{MCS}. These values are calculated assuming of a sampling rate of 20 MHz. Since IEEE 802.11 a/g channels have a bandwidth of 20 MHz, this is the minimum required sampling rate \cite{ieee2012}. However, some radios like the WARP boards use a higher sampling rate of 40 MHz. In this case, all indices have to be doubled.\\

All frames begin with the preamble, specifically the Short and Long Training Fields and the Signal Field. Both the STF and LTF have a duration of 8 $\mu$s. For the STF, this is 10 repetitions of a 0.8 $\mu$s symbol, for the LTF there are two repetitions of a 3.2 $\mu$s symbol, and the 1.6 $\mu$s cyclic prefix. The Signal Field consists of one standard \gls{OFDM} symbol with cyclic prefix. That is 4 $\mu$s in the case of IEEE 802.11.

In total, this means the preamble takes 20 $\mu$s. At 20 MHz sampling rate, that is $ 20 \cdot 10^{-6} \cdot 20 \cdot 10^6 = 400 $ samples. The Data field thus start at sample index 401. Within that, the Service Field as well as the Frame Control and Duration MAC header fields preceed the MAC addresses.\\

\begin{table}[ht]
	\begin{center}
		\begin{tabular}{|p{2.5cm}|p{4.5cm}|p{4.5cm}|}
			\hline
			\textbf{MCS} & \textbf{Address 1 (Destination)} & \textbf{Address 2 (Sender)} \\ \hline
			0 & 561 - 720 & 721 - 880 \\ \hline
			1 & 481 - 640 & 561 - 720 \\ \hline
			2 & 481 - 560 & 561 - 640 \\ \hline
			3 & 401 - 560 & 481 - 560 \\ \hline
			4 & 401 - 480 & 481 - 560 \\ \hline
			5 & 401 - 480 & 401 - 480 \\ \hline
			6 & 401 - 480 & 401 - 480 \\ \hline
			7 & 401 - 480 & 401 - 480 \\ \hline
		\end{tabular}
	\end{center}
	\caption{Sample Offsets of MAC Address Fields at different MCS}
	\label{tbl:sample-offsets}
\end{table}

\glspl{MCS} 0 and 2 have an important advantage. Only with these schemes does the above described region contain only the specific MAC address. All other schemes contain additional data, either before the address, behind it, or in both positions.


%% -----------------------------------------------------------------------------

\section{Matlab Implementation}

I built a proof of concept implementation of the presented technique in Matlab. Matlab was initially chosen based on the decision to use \gls{WARP} \glspl{SDR}. The WARPLab 7.5.1 Matlab \gls{SDK} \cite{warplab} provides easy-to-use high-level access to the radios. It was preferred by me over the alternative of using Python and \gls{USRP} boards.\\

The Matlab code is structured in different sections. First, utility functions implement the generation of MAC headers, modulating IEEE 802.11 data frames in the time-domain, and choosing sender MAC addresses randomly from a list. There are two different libraries used for modulation: MathWorks' WLAN System Toolbox \cite{wlantoolbox} as well as a custom IEEE 802.11 implementation developed at the \gls{SEEMOO} group at TU Darmstadt.

A number of simulation scripts measure the detection algorithm's performance under synthetic channel effects. The results of these are presented in chapter \ref{ch:evaluation}. A WARPLab script effectively does the same thing, but using three \gls{WARP} \glspl{SDR}. Finally, there are scripts than run a series of experiments varying different parameters, save the data, and generate figures to allow evaluation.\\

The core of the Matlab implementation is cross-correlation. Using the Signal Processing Toolbox \cite{signaltoolbox}, this can be done easily using the \texttt{xcorr} function. This function expects two complex sample series and returns a complex correlation vector and a real vector of offsets. The offsets range from the negative feature length till the positive length. This is because the data series can be slided against each other in both directions. Using this function is similar to this example for a Long Training Field symbol:\\

\begin{lstlisting}[captionpos=b,caption={Cross-Correlation of LTF symbol},label=lst:xcorr]
[correlation, offset] = xcorr(rx, lts_t);
\end{lstlisting}

Analysing the performance of my implementation revealed that most time was not spent on cross-correlation, but on the generation of the reference signal pool. I improved this code by applying the following optimizations.

First, since the sender detection only relies on correlating the samples that contain the MAC address, as described in section \ref{sec:mac-periods}, most of the generated signal is discarded anyways. This means that it is unnecessary to spend valuable time on calculating the MAC layer checksum, which is stored after the payload data. I simple use a placeholder value of 0x42424242 for the checksum. Furthermore, I do not generate the preamble, namely the Training and Signal Fields. This can be done by using the \texttt{wlanNonHTData} function from the WLAN System Toolbox. This function merely modulates the Data Field, in constrast to the \texttt{wlanWaveformGenerator} function.

Second, I store the reference signals in a cache that is reused in as many consecutive experiments as possible. All experiments were repeated for at least 100 iterations. Since the reference pool remains the same for all repetitions, using a shared variable for the entire set almost cuts the cost of a higher sample size to zero. This is because in relation to modulating a signal, calculating cross-correlations consumes several orders of magnitude less time (about 0.2 ms compared to 250 ms). This is especially good news because in a real-world application scenario, the generation of reference signals can be done ahead of time, and signals under test do not have to modulated since they are received already in the correct format.

Incorporating these optimizations reduced the runtime of the experiment varying the scrambler initialization, which is presented in section \ref{sec:ex-scrambler}, from an extrapolated 300 days to about 15 minutes on a consumer laptop. This not only allowed me to run the experiments at all, but also increase the number of repetitions, therefore largely enhancing the sample size.\\

To simulate channel effects, different models from both the WLAN System Toolbox and the Communications System Toolbox \cite{commtoolbox} were used. The exact functions are described in the corresponding sections in chapter \ref{ch:evaluation}.\\

As addressed in section \ref{sec:preamble-corr}, it is necessary to detect the offset between two frames in a collision. This is done using the \texttt{meshgrid} Matlab function. Listing \ref{lst:meshgrid} shows an example of calculating the field indices of both collided frames. The code compares the signal-to-training symbol correlation with a defined threshold and finds peaks in the data. These are then grouped into 4 clusters. This effectively removes noise and measuring inaccuracies causing a spike to last for more than one sample. Assuming that exactly two frames collided, the expected amount of peaks is 4.

\begin{lstlisting}[captionpos=b,caption={Collision Offset Detection using meshgrid},label=lst:meshgrid]
% Find peaks above a parametrized threshold
lts_peaks = find(abs(correlation) > LTS_CORR_THRESHOLD*max(abs(correlation)));

% Assuming two frames, there will be 4 high peaks
[~, C] = kmeans(lts_peaks', 4);
uniq_lts_peaks = sort(floor(C))';

% Select the best candidate correlation peak at LTS-payload boundary
[LTS1, LTS2] = meshgrid(uniq_lts_peaks, uniq_lts_peaks);
[lts_second_peak_index, y] = find(iswithin( ...
    LTS2-LTS1, ...
    length(lts_t)/1.2, ...
    length(lts_t)*1.2 ...
));

% Add 128 samples for the symbol itself
ind2.sig = uniq_lts_peaks(max(lts_second_peak_index)) + 128;
ind2.ltf = ind2.sig - 320; % subtract LTF length
ind2.stf = ind2.ltf - 320; % subtract STF length
ind2.payload = ind2.sig + 160; % add 4us SIG field
ind1.sig = uniq_lts_peaks(min(lts_second_peak_index)) + 128;
ind1.ltf = ind1.sig - 320;
ind1.stf = ind1.ltf - 320;
ind1.payload = ind1.sig + 160;
\end{lstlisting}

The \texttt{meshgrid} function then calculates a two-dimensional table of all possible offsets between every two peaks. Using a find function, I look for offsets that equal the length of one training symbol with a 20 percent margin.  The offset between the collided frames is the delay between such symbol matches.

Lastly, the signal field sample indicies are calculated as the last symbol correlation plus the lenght of that symbol. Start indices of the \gls{LTF}, \gls{STF}, and Data field are deduced accordingly.
