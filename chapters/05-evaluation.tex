%% -----------------------------------------------------------------------------

\chapter{Evaluation}\label{ch:evaluation}
\glsresetall % Resets all acronyms to not used

In this chapter, the proposed technique for detecting sender MAC addresses during collisions is evaluated using several simulations as well as experiments on WARP software-defined radios.

Possible questions and problems include the fact, that with higher \glspl{MCS}, there could be not enough samples to correlate the rather short 6 byte MAC address. Another interesting issue is the accuracy of the algorithm with increasing amounts of noise and fading.


%% -----------------------------------------------------------------------------

\section{Frequency-Domain Correlation}\label{sec:freqd-correlation}

During the implementation of the MAC address detection technique, I tried using cross-correlation in the frequency-domain. This means that instead of calculating the similarity between samples, complex symbols are correlated without mapping them into the time-domain. With this approach, the Fourier transform must be applied to the received signal.

It turns out to be at least very difficult, if not impossible, to detect senders in case of a collision with frequency-domain correlation. The reason for that is phase shift due to path delays. When a signal is received with an offset in the time-domain, the constellation is changed in the frequency-domain. This can be shown using the Fourier transform equation:

$$ F(f) = \int_{-\infty}^{\infty} s(t) \cdot e^{-2 \pi i f t} dt $$

Here, $ i $ is the imaginary unit, $ F(f) $ is the Fourier transform at frequency $ f $, and $ s(t) $ is the time-domain signal depending on $ t $. A time offset can now be expressed as $ t + \Delta $. Standard power laws then show that this offset introduces a constant multiplication factor on $ F(f) $, depending on $ \Delta $.

$$ F(f) = \int_{-\infty}^{\infty} s(t + \Delta) \cdot e^{-2 \pi i f \cdot (t + \Delta)} dt = \int_{-\infty}^{\infty} s(t + \Delta) \cdot e^{-2 \pi i f t} \cdot e^{-2 \pi i f \Delta} dt = $$
$$ = e^{-2 \pi i f \Delta} \cdot \int_{-\infty}^{\infty} s(t + \Delta) \cdot e^{-2 \pi i f t} dt $$

Since both $ s(t) $ and $ F(f) $ are complex functions, this multiplication is a rotation, or phase shift, in the complex constellation plane. Furthermore, the rotation is different for different frequencies $ f $.

This leads to a received constellation similar to that shown in figure \ref{fig:freqd-corr}. To create this figure, I applied a Rayleigh channel \cite{NEEDED} to a simulated collision signal, introducing a delay of a few nanoseconds. The signals are modulated with BPSK, so ideally the only constellation points should be $ 1 $ and $ -1 $. However, due to the above described rotation, the constellation is basically a circle.

\begin{figure}[ht]
	\centering
	\includegraphics[width=8cm]{gfx/images/freqd-correlation}
	\caption{Cross Correlation of Frequency-Domain Symbols after Channel}
	\label{fig:freqd-corr}
\end{figure}

This kind of path effects is not at all unusual in a IEEE 802.11 transmission. Under normal circumstances, the known preamble is used to calculate the inverted channel matrix of the path effects, as mentioned in section \ref{sec:multipath}.

When receiving a collision, there is however not only one preamble. Instead, the preambles of two different frames, which experienced different path effects, are added together. Since the preambles itself are designed to have a low autocorrelation \cite{NEEDED}, it is not easily possible to separate the two channel effects from each other. Therefore, I can not reverse the phase shift introduced on the OFDM symbols containing the MAC address.

As expected, experiments with cross-correlation in the frequency-domain without channel equalization were unsuccessful. I therefore disregarded this approach.


%% -----------------------------------------------------------------------------

\section{Time-Domain Correlation}

The experiments I did using time-domain cross-correlation are devided in two groups. First, I used Matlab to simulate different field variations and channel effects. Second, I used WARP boards to try the approach in a real-world scenario. The results of these experiments are summarized in the following sections.

When correlating time-domain samples, I always pre-generated reference samples and calculated the correlation only for the subset of samples that contains the MAC address. Section \ref{sec:mac-periods} describes which period of the signal this is.\\

Reference signals are modulated until just after the Fourier transform and adding of cyclic prefix. For the simulations, I used a sampling rate of 20 MHz, which is the default output of the Matlab WLAN System Toolbox. The WARP boards use a sampling frequency of 40 MHz however, so for these experiments I used interpolation to double the rate.

All experiments used realistic real-world MAC addresses, as described in section \ref{sec:real-world-macs}.


%% -----------------------------------------------------------------------------

\section{Real-World MAC Addresses}\label{sec:real-world-macs}

MAC addresses are 6 byte numbers, where the first 3 bytes are a vendor prefix, identifying the company that built the network interface. The remaining 3 bytes are a unique identifier for the specific hardware.

After initial tries with some artificial MAC addresses in the form of AB:CD:EF:12:34:56, I switched to using a sample set of real-world MAC addresses. This allowed for a closer simulation of an actual use-case for sender detection.\\

I collected 64 MAC addresses from devices that were connected to the wireless university eduroam network. The gathering was done in the afternoon on a weekday. I used airodump from the \texttt{aircrack-ng} software suite to dump all MAC addresses on the network into a file. The actual command looked like this:

\begin{lstlisting}[captionpos=b,caption={Capture Real-World MAC Addresses},label=lst:airodump]
airmon-ng start wlp0s20u1
airodump-ng --essid eduroam -a -o csv -w mac-addresses-eduroam.csv wlp0s20u1mon
\end{lstlisting}

It is important to have the wireless network interface set to promiscuitive mode. This mode instructs the driver to hand all received frames to the kernel. Otherwise, only frames that are addressed to or coming from the local station are gathered, while the rest is filtered. This would mean that only the router's and the station's own MAC address would be cached.

In a possible real-time usage scenario of the sender detection algorithm, it would also be important to use promiscuous mode in order to collect all MAC addresses. These are the addresses for which reference signals need to be modulated and cached.


%% -----------------------------------------------------------------------------

\section{Modulation and Coding Schemes}

Intuitively, the overall sender detection accuracy should decrease for higher \glspl{MCS}. Firstly, with a higher \gls{MCS} there are more payload bits encoded in every \gls{OFDM} symbol, as described in table \ref{tbl:mcs}. This means that when applying cross-correlation, the \gls{OFDM} symbol contains random data from the MAC header before and after the sender MAC address. Due to the nature of \gls{OFDM}, it is not possible to limit correlation to only a fraction of the symbol in the time-domain.

Secondly, the higher constellation itself, which comes with higher \gls{MCS}, means that payload data gets mapped to complex points in the constellation plane that are less distinct from each other. Therefore, different data can seem more similar under cross-correlation, making it harder to detect senders in the time-domain.\\

To evaluate the detection algorithm's performance, I measured the correctness of detected MAC addresses for each of the 8 available \glspl{MCS}. For every \gls{MCS}, 1000 experiments were conducted. The results are the stacked sums of times where a completely correct pair of senders were guessed, times where only one of the senders was correct, and the amount of failures, in the sense of both addresses being incorrect.

Figure \ref{fig:vary_mcs} is the resulting plot. Different \glspl{MCS} are spread out on the x axis. The stacked bars show the amount of experiments for each result category as described above. As expected, the detection accuracy decreases for higher \glspl{MCS}. It is worth mentioning that for low \glspl{MCS}, the performance is very good, better than I expected. Furthermore, it seems to decrease exponentionally, but to justify this more data would be needed.

\begin{figure}[H]
	\centering
	\setlength\figureheight{5cm}
	\setlength\figurewidth{0.9\textwidth}
	% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
	%\tikzset{external/remake next}
	\input{gfx/matlab/tikz/vary_mcs-20170608-1859-num_correct-64_addresses-1000_experiments.tikz}
	\caption{Results: Varying MCS for 1000 experiments}
	\label{fig:vary_mcs}
\end{figure}


%% -----------------------------------------------------------------------------

\section{Scrambler initialization}\label{sec:ex-scrambler}

As described in section \ref{sec:mac-and-phy}, the MAC layer payload data is scrambled before any modulation on the physical layer is applied. The scrambling uses a 7 bit state register, where 0 is no valid state. Therefore, 127 unique scrambler initialization values are possible.

If the scrambler initialization is important for the sender detection technique, specifically if the modulated reference signals must use the same initialization as the received frames, the amount of possible values linearly scales the algorithm's complexity. That is, for every cached MAC address, \gls{MCS} et cetera all scrambler initializations must be modulated and correlated. It is therefore very interesting to know whether that is the case, or whether the scrambler alternatively does not affect detection quality.\\

Figure \ref{fig:vary_scrambler} shows the detection performance for different scrambler initializations over 1000 experiments. The data is presented the same way as in the previous section as stacked bar plots denoting the amount of runs with 0, 1, and 2 corrects guesses. For all experiments, the \gls{MCS} 0 was used. While the simulated received frame was modulated with scrambler initialization 1, correlation was calculated against 127 reference signals with different scrambler values.

The results show that indeed the scrambler initialization is very important for detection quality. While the performance is very good for the correct initialization value 1, for all other values the accuracy is low. However, related research mentions that some network interfaces seem to not choose the scrambler initialization at random \cite{NEEDED}, contradictory to the IEEE 802.11 standard. These devices use a static initialization for every frame, or increment the value after every transmission. This could be exploited by limiting the reference signals to such that are expected in the current network, therefore avoiding time spent on correlations that are unpromising. Since the MAC addresses of stations in the network are cached, the interface types and vendors are known. This could lead to some interesting future work.

\begin{figure}[H]
	\centering
	% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
	%\tikzset{external/remake next}
	\includegraphics[width=0.9\textwidth,height=5cm]{gfx/images/stock-clouds}
	\caption[Results: Varying Scrambler Initialization for 1000 experiments]{Results: Varying Scrambler Initialization for 1000 experiments at MCS 0}
	\label{fig:vary_scrambler}
\end{figure}


%% -----------------------------------------------------------------------------

\section{Preceeding Data Variations}

Similarly to the scrambler initialization, the MAC header field preceeding the sender MAC address could also influence detection quality. This is due to the convolutional encoder as described in section \ref{sec:mac-and-phy}. The field before the sender MAC address in a data frame is the destination MAC address. In the following experiment, I measured to which extent the value of the destination address affects the accuracy of my detection technique.\\

Figure \ref{fig:vary_dest} shows the results in the same way as for the previous figures. Since the convolutional encoder uses a 7 bit state, only the last 7 bits of the destination MAC address matter. After these last 7 bits, the register is synchronized to the same state, regardless of the preceeding first 41 bits of the address. This makes up for a total of 128 different values that are evaluated with 1000 experiments each. As for the scrambler initialitation, the experiments are done at \gls{MCS} 0.

\begin{figure}[H]
	\centering
	% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
	%\tikzset{external/remake next}
	\includegraphics[width=0.9\textwidth,height=5cm]{gfx/images/stock-clouds}
	\caption[Results: Varying Destination MAC Address for 1000 experiments]{Results: Varying Destination MAC Address for 1000 experiments at MCS 0}
	\label{fig:vary_dest}
\end{figure}

It turns out that unlike the scrambler initialization, preceeding payload data does not really have a measurable effect. Detection quality is comparable regardless of the trailing bits of the MAC address. I discuss possible reasons for this in section \ref{sec:detection-quality}. An important implication of this result is that it is not necessary to check all 128 possible encoder states for every collision in real-time, which would be another linear scaling factor for the computational complexity of the algorithm.


%% -----------------------------------------------------------------------------

\section{Channel Models}

Use channel models B, D, and E (most common).

\begin{figure}[p]
	\centering
	\setlength\figureheight{3cm}
	\setlength\figurewidth{0.40\textwidth}
	\begin{tabular}{cc}
		% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
		%\tikzset{external/remake next}
		\subfloat[MCS 0]{\input{gfx/matlab/tikz/vary_tgn-20170609-0142-num_correct-64_addresses-100_experiments-mcs_0.tikz}} &
		\subfloat[MCS 1]{\input{gfx/matlab/tikz/vary_tgn-20170609-0142-num_correct-64_addresses-100_experiments-mcs_1.tikz}} \\
		\subfloat[MCS 2]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_2.tikz}} &
		\subfloat[MCS 3]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_3.tikz}} \\
		\subfloat[MCS 4]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_4.tikz}} &
		\subfloat[MCS 5]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_5.tikz}} \\
		\subfloat[MCS 6]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_6.tikz}} &
		\subfloat[MCS 7]{\input{gfx/matlab/tikz/vary_tgn-20170609-0143-num_correct-64_addresses-100_experiments-mcs_7.tikz}} \\
	\end{tabular}
	\caption{Varying TGn Channel for 100 Experiments}
	\label{fig:vary_tng}
\end{figure}

\begin{figure}[p]
	\centering
	\setlength\figureheight{3cm}
	\setlength\figurewidth{0.40\textwidth}
	\begin{tabular}{cc}
		% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
		%\tikzset{external/remake next}
		\subfloat[MCS 0]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_0.tikz}} &
		\subfloat[MCS 1]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_1.tikz}} \\
		\subfloat[MCS 2]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_2.tikz}} &
		\subfloat[MCS 3]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_3.tikz}} \\
		\subfloat[MCS 4]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_4.tikz}} &
		\subfloat[MCS 5]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_5.tikz}} \\
		\subfloat[MCS 6]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_6.tikz}} &
		\subfloat[MCS 7]{\input{gfx/matlab/tikz/vary_trms-20170609-0248-num_correct-64_addresses-10_experiments-mcs_7.tikz}} \\
	\end{tabular}
	\caption{Varying $t_{RMS}$ in a Standard Channel for 100 Experiments}
	\label{fig:vary_trms}
\end{figure}


%% -----------------------------------------------------------------------------

\section{WARP Experiments}

\begin{figure}[H]
	\centering
	\setlength\figureheight{5cm}
	\setlength\figurewidth{0.9\textwidth}
	% uncomment the following line to recompile the figure when it changes otherwise a cached version is used
	%\tikzset{external/remake next}
	\input{gfx/matlab/tikz/capture_collision-20170622-1533-ltf_correlation.tikz}
	\caption{Preamble Correlation in WARP Experiment}
	\label{fig:warp_preamble_corr}
\end{figure}
